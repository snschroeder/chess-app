/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/gamestate.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/harmony-module.js?");

/***/ }),

/***/ "./src/bishop.js":
/*!***********************!*\
  !*** ./src/bishop.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Bishop; });\n/* harmony import */ var _piece__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece */ \"./src/piece.js\");\n\n\nclass Bishop extends _piece__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(color, position) {\n        super(color, position, 'bishop', 3);\n    }\n    _generate_move_sequences() {\n        const moves = [], upRight = [], upLeft = [], downRight = [], downLeft = [];\n        let file = this.position[0], rank = this.position[1];\n\n        for (let i = 1; i < gameState.board.getDims(); i++) {\n            upRight.push([file + i, rank + i]);\n            upLeft.push([file + i, rank - i]);\n            downRight.push([file - i, rank + i]);\n            downLeft.push([file -i, rank - i]);\n        }\n        moves.push(upRight), moves.push(upLeft), moves.push(downRight), moves.push(downLeft);\n        return moves;\n    }\n}\n\n//# sourceURL=webpack:///./src/bishop.js?");

/***/ }),

/***/ "./src/board.js":
/*!**********************!*\
  !*** ./src/board.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _rook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rook */ \"./src/rook.js\");\n/* harmony import */ var _knight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./knight */ \"./src/knight.js\");\n/* harmony import */ var _bishop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bishop */ \"./src/bishop.js\");\n/* harmony import */ var _queen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./queen */ \"./src/queen.js\");\n/* harmony import */ var _king__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./king */ \"./src/king.js\");\n/* harmony import */ var _pawn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pawn */ \"./src/pawn.js\");\n/* harmony import */ var _square__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./square */ \"./src/square.js\");\n\n\n\n\n\n\n\n\nmodule.export = class Board {\n    constructor() {\n        this.dims = 8;\n        this.playArea = new Array(this.dims);\n        this.alpha = 'ABCDEFGH';\n    }\n\n    createBoard() {\n        for (let i = 0; i < this.dims; i++) {\n            this.playArea[i] = new Array(this.dims);\n        }\n    }\n\n    assignNotation() {\n        for (let i = 0; i < this.dims; i++) {\n            for (let j = 0; j < this.dims; j++) {\n                this.playArea[i][j] = new _square__WEBPACK_IMPORTED_MODULE_6__[\"default\"](i, j);\n            }\n        }\n    }\n\n    assignColor() {\n        for (let i = 0; i < this.dims; i ++) {\n            if (i % 2 === 0) {\n                for (let j = 0; j < this.dims; j+=2) {\n                    this.playArea[i][j].setColor('dark');\n                    this.playArea[i][j + 1].setColor('light');\n                }\n            } else {\n                for (let k = 0; k < this.dims; k +=2) {\n                    this.playArea[i][k].setColor('light');\n                    this.playArea[i][k + 1].setColor('dark');\n                }\n            }\n        }\n    }\n\n    populatePieces() {\n        let pieces = [];\n        pieces.push(new _rook__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('white', [0, 0]));\n        pieces.push(new _rook__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('white', [0, 7]));\n        pieces.push(new _knight__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('white', [0, 1]));\n        pieces.push(new _knight__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('white', [0, 6]));\n        pieces.push(new _bishop__WEBPACK_IMPORTED_MODULE_2__[\"default\"]('white', [0, 2]));\n        pieces.push(new _bishop__WEBPACK_IMPORTED_MODULE_2__[\"default\"]('white', [0, 5]));\n        pieces.push(new _queen__WEBPACK_IMPORTED_MODULE_3__[\"default\"]('white', [0, 3]));\n        pieces.push(new _king__WEBPACK_IMPORTED_MODULE_4__[\"default\"]('white', [0, 4]));\n        for (let i = 0; i < gameState.board.getDims(); i++) {\n            pieces.push(new _pawn__WEBPACK_IMPORTED_MODULE_5__[\"default\"]('white', [1, i]));\n        }\n        pieces.push(new _rook__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('black', [7, 0]));\n        pieces.push(new _rook__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('black', [7, 7]));\n        pieces.push(new _knight__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('black', [7, 1]));\n        pieces.push(new _knight__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('black', [7, 6]));\n        pieces.push(new _bishop__WEBPACK_IMPORTED_MODULE_2__[\"default\"]('black', [7, 2]));  \n        pieces.push(new _bishop__WEBPACK_IMPORTED_MODULE_2__[\"default\"]('black', [7, 5]));\n        pieces.push(new _queen__WEBPACK_IMPORTED_MODULE_3__[\"default\"]('black', [7, 3])); \n        pieces.push(new _king__WEBPACK_IMPORTED_MODULE_4__[\"default\"]('black', [7, 4]));\n        for (let i = 0; i < gameState.board.getDims(); i++) {\n            pieces.push(new _pawn__WEBPACK_IMPORTED_MODULE_5__[\"default\"]('black', [6, i]));\n        }\n        pieces.forEach(piece => {\n            gameState.board.getPlayArea()[piece.position[0]][piece.position[1]].setPiece(piece);\n        });\n    }\n\n    findPieceByName(name, color) {\n        let piece;\n        gameState.board.playArea.forEach(row => row.forEach(col => {\n            if (col.getPiece() !== null) {\n                if (col.getPiece().getName() === name && col.getPiece().getColor() === color) {\n                    piece = col.getPiece();\n                }\n            }\n        }))  \n        return piece;\n    }\n\n    \n    getPieceBySquare(coords) {\n        if (this.getSquare(coords[0], coords[1]).getPiece() === null) {\n            return 'no piece at that square';\n        } else {\n            return this.getSquare(coords[0], coords[1]).getPiece();\n        }\n    }\n\n    getDims() {return this.dims;}\n    getAlpha() {return this.alpha;}\n    getSquare(rank, file) {return this.playArea[rank][file];}\n    getPlayArea() {return this.playArea;}\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n// class Piece {\n//     constructor(color, position, name, value) {\n//         this.color = color;\n//         this.position = position;\n//         this.name = name;\n//         this.value = value;\n//         this.board = gameState.board;\n//     }\n\n//     //validates moves for rook, bishop, queen, and king\n\n//     //can I use object destructuring here to unpack the variables and then repack them at the end?\n\n//     valid_moves() {\n\n//         let generatedMoves = this._generate_move_sequences().moves;\n//         let origin = this._generate_move_sequences().origin;\n\n//         generatedMoves = generatedMoves.map(direction => direction.filter(pos => !(pos[0] < 0 || pos[0] > gameState.board.getDims() -1 || pos[1] < 0 || pos[1] > gameState.board.getDims() -1)));\n\n//         generatedMoves.forEach((direction) => direction.forEach((pos, index) => {\n//             if (gameState.board.getSquare(pos[0], pos[1]).getPiece() !== null && gameState.board.getSquare(pos[0], pos[1]).getPiece().getColor() === this.color) {\n//                 direction.splice(index);\n//             } else if (gameState.board.getSquare(pos[0], pos[1]).getPiece() !== null && gameState.board.getSquare(pos[0], pos[1]).getPiece().getColor() !== this.color) {\n//                 direction.splice(index + 1);\n//             }\n//         }))\n\n//         generatedMoves = generatedMoves.filter(move => move.length !== 0);\n\n//         return {name: name, origin: origin, moves: generatedMoves};\n\n//     }\n\n//     _generate_move_sequences() {return [];}\n//     getColor() {return this.color;}\n//     getPosition() {return this.position;}\n//     getName() {return this.name;}\n// }\n\n// //Ask Chris about the object - can it be declared partially in the super class?\n\n// class Rook extends Piece {\n//     constructor(color, position) {\n//         super(color, position, 'rook', 5);\n//         this.hasNotMoved = true;\n//     }\n//     _generate_move_sequences() {\n//         let moves = [], rankUp = [], rankDown = [], fileRight = [], fileLeft = [];\n//         let file = this.position[0], rank = this.position[1];\n\n//         for (let i = 1; i < gameState.board.getDims(); i++) {\n//             fileRight.push([file + i, rank]);\n//             fileLeft.push([file - i, rank]);\n//             rankUp.push([file, rank + i]);\n//             rankDown.push([file, rank - i]);\n//         }\n//         moves.push(fileRight), moves.push(fileLeft), moves.push(rankUp), moves.push(rankDown);\n//         return {name: this.name, origin: this.position, moves: moves};\n//     }\n//     getHasNotMoved() {return this.hasNotMoved;}\n// }\n\n// class Bishop extends Piece {\n//     constructor(color, position) {\n//         super(color, position, 'bishop', 3);\n//     }\n//     _generate_move_sequences() {\n//         const moves = [], upRight = [], upLeft = [], downRight = [], downLeft = [];\n//         let file = this.position[0], rank = this.position[1];\n\n//         for (let i = 1; i < gameState.board.getDims(); i++) {\n//             upRight.push([file + i, rank + i]);\n//             upLeft.push([file + i, rank - i]);\n//             downRight.push([file - i, rank + i]);\n//             downLeft.push([file -i, rank - i]);\n//         }\n//         moves.push(upRight), moves.push(upLeft), moves.push(downRight), moves.push(downLeft);\n//         return {name: this.name, origin: this.position, moves: moves};\n//     }\n// }\n\n// class Knight extends Piece {\n//     constructor(color, position) {\n//         super(color, position, 'knight', 3);\n//     }\n//     _generate_move_sequences() {\n//         const moves = [];\n//         let file = this.position[0], rank = this.position[1];\n//         moves.push([file + 2, rank + 1])\n//         moves.push([file + 2, rank - 1])\n//         moves.push([file + 1, rank + 2])\n//         moves.push([file + 1, rank - 2])\n//         moves.push([file - 2, rank + 1])\n//         moves.push([file - 2, rank -1])\n//         moves.push([file - 1, rank + 2])\n//         moves.push([file - 1, rank - 2])\n\n//         return {name: this.name, origin: this.position, moves: moves};\n//     }\n\n//     valid_moves() {\n//         let generatedMoves = this._generate_move_sequences().moves;\n//         let origin = this._generate_move_sequences().origin;\n\n//         generatedMoves = generatedMoves.filter(pos => !(pos[0] < 0 || pos[0] > gameState.board.getDims() -1 || pos[1] < 0 || pos[1] > gameState.board.getDims() -1));\n//         generatedMoves = generatedMoves.filter(move => gameState.board.getSquare(move[0], move[1]).getPiece() === null || gameState.board.getSquare(move[0], move[1]).getPiece().getColor() !== this.color);\n//         return {origin: origin, moves: generatedMoves};\n//     }\n// }\n\n// class Queen extends Piece {\n//     constructor(color, position) {\n//         super(color, position, 'queen', 9);\n//     }\n//     _generate_move_sequences() {\n//         const moves = [], upRight = [], upLeft = [], downRight = [], downLeft = [], rankUp = [],rankDown = [], fileRight = [], fileLeft = [];\n//         let file = this.position[0], rank = this.position[1];\n\n//         for (let i = 1; i < gameState.board.getDims(); i++) {\n//             upRight.push([file + i, rank + i]);\n//             upLeft.push([file + i, rank - i]);\n//             downRight.push([file - i, rank + i]);\n//             downLeft.push([file -i, rank - i]);\n//             rankUp.push([file + i, rank]);\n//             rankDown.push([file - i, rank]);\n//             fileRight.push([file, rank + i]);\n//             fileLeft.push([file, rank - i]);\n//         }\n//         moves.push(upRight), moves.push(upLeft), moves.push(downRight), moves.push(downLeft);\n//         moves.push(rankUp), moves.push(rankDown), moves.push(fileRight), moves.push(fileLeft);\n//         return {name: this.name, origin: this.position, moves: moves};\n//     }\n// }\n\n// class King extends Piece {\n//     constructor(color, position) {\n//         super(color, position, 'king', Number.POSITIVE_INFINITY);\n//         this.hasNotMoved = true;\n//     }\n//     _generate_move_sequences() {\n//         const moves = [], upRight = [], upLeft = [], downRight = [], downLeft = [], rankUp = [],rankDown = [], fileRight = [], fileLeft = [];\n//         let file = this.position[0], rank = this.position[1];\n\n//         upRight.push([file + 1, rank + 1]);\n//         upLeft.push([file + 1, rank - 1]);\n//         downRight.push([file - 1, rank + 1]);\n//         downLeft.push([file -1, rank - 1]);\n//         rankUp.push([file + 1, rank]);\n//         rankDown.push([file - 1, rank]);\n//         fileRight.push([file, rank + 1]);\n//         fileLeft.push([file, rank - 1]);\n\n//         moves.push(upRight), moves.push(upLeft), moves.push(downRight), moves.push(downLeft);\n//         moves.push(rankUp), moves.push(rankDown), moves.push(fileRight), moves.push(fileLeft);\n//         return {name: this.name, origin: this.position, moves: moves};\n//     }\n\n//     castle(direction) {\n\n//     }\n\n//     getHasNotMoved() {return this.hasNotMoved;}\n// }\n\n// // Pawn validate moves will take a second to update - look at this closer after class\n\n// class Pawn extends Piece {\n//     constructor(color, position) {\n//         super(color, position, 'pawn', 1);\n//             this.hasNotMoved = true;\n//     }\n//     _generate_move_sequences() {\n\n//         let file = this.position[0], rank = this.position[1];\n\n//         const white_moves = {\n//             forward: [file + 1, rank],\n//             twoSquares: [file + 2, rank],\n//             capRight: [file + 1, rank + 1],\n//             capLeft: [file + 1, rank - 1],\n//         }\n\n//         const black_moves = {\n//             forward: [file - 1, rank],\n//             twoSquares: [file - 2, rank],\n//             capRight: [file - 1, rank + 1],\n//             capLeft: [file - 1, rank - 1],\n//         }\n\n//         if (this.color === 'white') {\n//             return {name: this.name, origin: this.position, moves: white_moves};\n//         } else {\n//             return {name: this.name, black_moves: this.position, moves: black_moves};\n//         }\n//     }\n\n//     valid_moves() {\n//         let generatedMoves = this._generate_move_sequences().moves;\n//         let origin = this._generate_move_sequences().origin;\n//         //if moving forward one space would put the pawn off the board in either direction, delete both \n//         if (generatedMoves.forward[0] > gameState.board.getDims() - 1 || generatedMoves.forward[0] < 0) {\n//             delete generatedMoves.forward;\n//             delete generatedMoves.twoSquares;\n//         }\n//         //if forward one space hits a same color piece, delete both forward options\n//         if (gameState.board.getSquare(generatedMoves.forward[0], generatedMoves.forward[1]).getPiece() !== null && gameState.board.getSquare(generatedMoves.forward[0], generatedMoves.forward[1]).getPiece().getColor() === this.color) {\n//             delete generatedMoves.forward;\n//             delete generatedMoves.twoSquares;\n//         }\n//         //if forward one space is okay, we need to verify forward 2 spaces is also okay. If not, we delete forward two\n//         if (generatedMoves.twoSquares !== undefined) {\n//             if (gameState.board.getSquare(generatedMoves.twoSquares[0], generatedMoves.twoSquares[1]).getPiece() !== null && gameState.board.getSquare(generatedMoves.twoSquares[0], generatedMoves.twoSquares[1]).getPiece().getColor() === this.color) {\n//                 delete generatedMoves.twoSquares;\n//             }\n//         }\n//         //check if capturing right is still on the board. If not, remove capRight\n//         if (generatedMoves.capRight[0]> gameState.board.getDims() - 1 || generatedMoves.capRight[0] < 0 || generatedMoves.capRight[1]> gameState.board.getDims() - 1 || generatedMoves.capRight[1] < 0) {\n//             delete generatedMoves.capRight;\n//         }\n//         //check if capturing left would is still on the board. If not, remove capLeft\n//         if (generatedMoves.capLeft[0]> gameState.board.getDims() - 1 || generatedMoves.capLeft[0] < 0 || generatedMoves.capLeft[1]> gameState.board.getDims() - 1 || generatedMoves.capLeft[1] < 0) {\n//             delete generatedMoves.capLeft;\n//         }\n//         if (generatedMoves.capRight !== undefined) {\n//         //check that an enemy piece is present to capture right. If not, remove capRight\n//             if (gameState.board.getSquare(generatedMoves.capRight[0], generatedMoves.capRight[1]).getPiece() === null || gameState.board.getSquare(generatedMoves.capRight[0], generatedMoves.capRight[1]).getPiece().getColor() === this.color) {\n//                 delete generatedMoves.capRight;\n//             }\n//         }\n//         if (generatedMoves.capLeft !== undefined) {\n//             //check that an enemy piece is present to capture left. If not, remove capLeft\n//             if (gameState.board.getSquare(generatedMoves.capLeft[0], generatedMoves.capLeft[1]).getPiece() === null || gameState.board.getSquare(generatedMoves.capLeft[0], generatedMoves.capLeft[1]).getPiece().getColor() === this.color) {\n//                 delete generatedMoves.capLeft;\n//             }\n//         }\n\n//         return {origin: origin, moves: Object.values(generatedMoves)};\n//         }\n\n//     getHasNotMoved() {return this.hasNotMoved;}\n// }\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))\n\n//# sourceURL=webpack:///./src/board.js?");

/***/ }),

/***/ "./src/gamestate.js":
/*!**************************!*\
  !*** ./src/gamestate.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _board__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board */ \"./src/board.js\");\n\n\nclass GameState {\n    constructor() {\n        this.board = new _board__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()\n        this.moveList = [];\n        this.currentMove = ['white', 'black'];\n        this.currentState = [\n            {player: 'white', pieceTotal: 0},\n            {player: 'black', pieceTotal: 0}\n        ]\n    }\n\n    move(piece, dest) {\n        let piecePos = piece.getPosition();\n        if (piece.getColor() !== this.currentMove[0]) {\n            return 'invalid move, please try again';\n\n        }\n        piece.valid_moves().forEach(possDest => {\n            if (this.moveComparator(possDest, dest)) {\n                if (this.board.getSquare(dest[0], dest[1]).getPiece() !== null) {\n                    this.board.getSquare(dest[0], dest[1]).removePiece();\n                    this.board.getSquare(dest[0], dest[1]).setPiece(piece);\n                    this.board.getSquare(piecePos[0], piecePos[1]).removePiece()\n                    this.currentMove.reverse();\n                    return 'successful move'\n                } else {\n                    this.board.getSquare(dest[0], dest[1]).setPiece(piece);\n                    this.board.getSquare(piecePos[0], piecePos[1]).removePiece()\n                    this.currentMove.reverse();\n                    return 'successful move'\n                }\n            }\n        }) \n    }\n\n    checkForCheck(kingPos, attackSide) {\n        let attackingMoves = gameState.generateAllMovesByColor(attackSide).flat();\n        attackingMoves = attackingMoves.filter(move => this.moveComparator(move, kingPos))\n        \n        if (attackingMoves.length === 1) {\n            return 1;\n        } else if (attackingMoves.length === 2) {\n            return 2;\n        } else {\n            return 0;\n        }\n    }\n\n\n\n\n/*\n    turn sequence\n        check for check\n            if check, check for checkmate\n                if checkmate, game ends\n            if not checkmate, player must move to get out of check\n        if not check\n            take a move input\n                if move is valid - i.e., must be within valid moves array, must not put your king in check\n        \n        check for opponent check\n            if check, check for checkmate\n*/\n\n\n/*\nlook at the currentMove's king -\n    run a check for all opposite color pieces, pulling in their valid moves. Combine these into one array\n    if one of the moves hits the king, king can move, or a piece can block\n\n    if two options hit the king's current square, can only move the king\n\n    after current move player has made a move, check again\n        if still under attack, move is invalid\n\n\n\n    is it better to pull all moves as one array, or to pull an array contain each piece on side and then checking their valid moves one by one as we sequence through the array of objs?\n\n*/\n\n\n\n\n\n    checkForCheckmate(attackSide, defSide) {\n        let check = this.checkForCheck(attackSide, defSide);\n        let defKing = gameState.board.findPieceByName('king', defSide);\n        let kingMoves = defKing.valid_moves();\n        let kingPos = defKing.position;\n\n        let attackingMoves = gameState.generateAllMovesByColor(attackSide).flat();\n        let defMoves = gameState.generateAllMovesByColor(defSide).flat();\n\n        console.log(kingPos)\n        console.log(attackingMoves);\n        console.log(defMoves)\n\n        if (check === 2) {\n            kingMoves.filter(move => {\n                attackingMoves.forEach(attackingMove => {\n                    return (!this.moveComparator(move, attackingMove))\n                })\n            })\n            if (kingMoves.length === 0) {\n            return 'checkmate'\n            } else {\n                kingMoves.forEach(move => {\n                    if (this.checkForCheck(move, attackSide, defSide) === 1 || this.checkForCheck(move, attackSide, defSide) === 2) {\n                        return 'checkmate'\n                    }\n                })\n            }\n        } else {\n\n\n\n        }\n\n        // let attackingMoves = gameState.generateAllMovesByColor(this.currentState[1].color);\n        // let king = gameState.board.findPieceByName('king', this.currentMove[0]);\n        // let kingMoves = king.valid_moves();\n        // console.log(kingMoves);\n        \n\n        // kingMoves.filter(move => {\n        //     attackingMoves.forEach(attackingMove => {\n        //         return (!this.moveComparator(move, attackingMove))\n        //     })\n        // })\n        // if (kingMoves.length === 0) {\n        //     return 'checkmate'\n        // }\n\n    }\n/*\nlook at currentMove's king\n    if king is in check and all valid moves are covered by enemy moves AND no pieces can block the check, return checkmate\n*/\n    /**\n     * \n     * @param {string} color - 'white' or 'black'\n     * @returns {array} array of arrays with all possible moves for the color selected\n     * \n     */\n\n\n     // add origin here\n    generateAllMovesByColor(color) {\n        let allMoves = [];\n\n        gameState.board.playArea.forEach(row => row.forEach(col => {\n            if (col.getPiece() !== null && col.getPiece().getColor() === color && ['queen', 'bishop', 'rook'].includes(col.getPiece().getName())) {\n                allMoves.push(col.getPiece().valid_moves().moves.flat())\n            } else if (col.getPiece() !== null && col.getPiece().getColor()) {\n                allMoves.push(col.getPiece().valid_moves().moves)\n            }\n        }))\n        return allMoves;\n    }\n\n\n    // generateAllMoveOriginObjs(color) {\n    //     let moveOrigin = [];\n    //         gameState.board.playArea.forEach(row => row.forEach(col => {\n    //             if (col.getPiece() !== null && col.getPiece().getColor()) {\n    //                 moveOrigin.push(col.getPiece().valid_moves())\n    //             }\n    // }\n\n\n\n\n\n    moveComparator (possibleDest, desiredDest) {return (possibleDest[0] === desiredDest[0] && possibleDest[1] === desiredDest[1]);}\n}\n\n\n\n\n\n\ngameState = new GameState();\ngameState.board.createBoard();\ngameState.board.assignNotation();\ngameState.board.assignColor();\ngameState.board.populatePieces();\nconsole.log(gameState.board.playArea);\n\nconsole.log(gameState.checkForCheck([0, 4], 'white'));\n\n\n\n\n// console.log(gameState.board.getSquare(1, 1).getPiece().valid_moves());\n//console.log(gameState.generateAllMovesByColor('black'));\n\n\n\n// console.log(gameState.checkForCheckmate('black', 'white'));\n\n\n// console.log(gameState.board.playArea);\n// console.log(gameState.checkForCheckmate())\n\n//console.log(board.playArea[0][0].getPiece().valid_moves());  \n\n// const white_rook = new Rook('white', [3, 3]);\n\n// const white_bishop = new Bishop('white', [2, 3]);\n\n// const white_queen = new Queen('white', [0, 0]);\n\n\n\n// console.log(white_bishop.valid_moves());\n// console.log(white_queen.valid_moves());\n\n\n// gameState.move(gameState.board.playArea[1][3].getPiece(), [2, 3]);\n// gameState.move(gameState.board.playArea[6][3].getPiece(), [4, 3]);\n\n//  getSquareByCoord(rank, file) {return this.board.getSquare(rank, file);}\n\n\n\n//# sourceURL=webpack:///./src/gamestate.js?");

/***/ }),

/***/ "./src/king.js":
/*!*********************!*\
  !*** ./src/king.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return King; });\n/* harmony import */ var _piece__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece */ \"./src/piece.js\");\n\n\nclass King extends _piece__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(color, position) {\n        super(color, position, 'king', Number.POSITIVE_INFINITY);\n        this.hasNotMoved = true;\n    }\n    _generate_move_sequences() {\n        const moves = [], upRight = [], upLeft = [], downRight = [], downLeft = [], rankUp = [],rankDown = [], fileRight = [], fileLeft = [];\n        let file = this.position[0], rank = this.position[1];\n\n        upRight.push([file + 1, rank + 1]);\n        upLeft.push([file + 1, rank - 1]);\n        downRight.push([file - 1, rank + 1]);\n        downLeft.push([file -1, rank - 1]);\n        rankUp.push([file + 1, rank]);\n        rankDown.push([file - 1, rank]);\n        fileRight.push([file, rank + 1]);\n        fileLeft.push([file, rank - 1]);\n\n        moves.push(upRight), moves.push(upLeft), moves.push(downRight), moves.push(downLeft);\n        moves.push(rankUp), moves.push(rankDown), moves.push(fileRight), moves.push(fileLeft);\n        return moves;\n    }\n\n    castle(direction) {\n\n    }\n\n    getHasNotMoved() {return this.hasNotMoved;}\n}\n\n//# sourceURL=webpack:///./src/king.js?");

/***/ }),

/***/ "./src/knight.js":
/*!***********************!*\
  !*** ./src/knight.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Knight; });\n/* harmony import */ var _piece__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece */ \"./src/piece.js\");\n\n\nclass Knight extends _piece__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(color, position) {\n        super(color, position, 'knight', 3);\n    }\n    _generate_move_sequences() {\n        const moves = [];\n        let file = this.position[0], rank = this.position[1];\n        moves.push([file + 2, rank + 1])\n        moves.push([file + 2, rank - 1])\n        moves.push([file + 1, rank + 2])\n        moves.push([file + 1, rank - 2])\n        moves.push([file - 2, rank + 1])\n        moves.push([file - 2, rank -1])\n        moves.push([file - 1, rank + 2])\n        moves.push([file - 1, rank - 2])\n\n        return moves;\n    }\n\n    valid_moves() {\n        let generatedMoves = this._generate_move_sequences();\n\n        generatedMoves = generatedMoves.filter(pos => !(pos[0] < 0 || pos[0] > gameState.board.getDims() -1 || pos[1] < 0 || pos[1] > gameState.board.getDims() -1));\n        generatedMoves = generatedMoves.filter(move => gameState.board.getSquare(move[0], move[1]).getPiece() === null || gameState.board.getSquare(move[0], move[1]).getPiece().getColor() !== this.color);\n        return generatedMoves;\n    }\n}\n\n//# sourceURL=webpack:///./src/knight.js?");

/***/ }),

/***/ "./src/pawn.js":
/*!*********************!*\
  !*** ./src/pawn.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Pawn; });\n/* harmony import */ var _piece__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece */ \"./src/piece.js\");\n\n\nclass Pawn extends _piece__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(color, position) {\n        super(color, position, 'pawn', 1);\n            this.hasNotMoved = true;\n    }\n    _generate_move_sequences() {\n\n        let file = this.position[0], rank = this.position[1];\n\n        const white_moves = {\n            forward: [file + 1, rank],\n            twoSquares: [file + 2, rank],\n            capRight: [file + 1, rank + 1],\n            capLeft: [file + 1, rank - 1],\n        }\n\n        const black_moves = {\n            forward: [file - 1, rank],\n            twoSquares: [file - 2, rank],\n            capRight: [file - 1, rank + 1],\n            capLeft: [file - 1, rank - 1],\n        }\n\n        if (this.color === 'white') {\n            return white_moves;\n        } else {\n            return black_moves;\n        }\n    }\n\n    valid_moves() {\n        let generatedMoves = this._generate_move_sequences();\n\n        //if moving forward one space would put the pawn off the board in either direction, delete both \n        if (generatedMoves.forward[0] > gameState.board.getDims() - 1 || generatedMoves.forward[0] < 0) {\n            delete generatedMoves.forward;\n            delete generatedMoves.twoSquares;\n        }\n        //if forward one space hits a same color piece, delete both forward options\n        if (gameState.board.getSquare(generatedMoves.forward[0], generatedMoves.forward[1]).getPiece() !== null && gameState.board.getSquare(generatedMoves.forward[0], generatedMoves.forward[1]).getPiece().getColor() === this.color) {\n            delete generatedMoves.forward;\n            delete generatedMoves.twoSquares;\n        }\n        //if forward one space is okay, we need to verify forward 2 spaces is also okay. If not, we delete forward two\n        if (generatedMoves.twoSquares !== undefined) {\n            if (gameState.board.getSquare(generatedMoves.twoSquares[0], generatedMoves.twoSquares[1]).getPiece() !== null && gameState.board.getSquare(generatedMoves.twoSquares[0], generatedMoves.twoSquares[1]).getPiece().getColor() === this.color) {\n                delete generatedMoves.twoSquares;\n            }\n        }\n        //check if capturing right is still on the board. If not, remove capRight\n        if (generatedMoves.capRight[0]> gameState.board.getDims() - 1 || generatedMoves.capRight[0] < 0 || generatedMoves.capRight[1]> gameState.board.getDims() - 1 || generatedMoves.capRight[1] < 0) {\n            delete generatedMoves.capRight;\n        }\n        //check if capturing left would is still on the board. If not, remove capLeft\n        if (generatedMoves.capLeft[0]> gameState.board.getDims() - 1 || generatedMoves.capLeft[0] < 0 || generatedMoves.capLeft[1]> gameState.board.getDims() - 1 || generatedMoves.capLeft[1] < 0) {\n            delete generatedMoves.capLeft;\n        }\n        if (generatedMoves.capRight !== undefined) {\n        //check that an enemy piece is present to capture right. If not, remove capRight\n            if (gameState.board.getSquare(generatedMoves.capRight[0], generatedMoves.capRight[1]).getPiece() === null || gameState.board.getSquare(generatedMoves.capRight[0], generatedMoves.capRight[1]).getPiece().getColor() === this.color) {\n                delete generatedMoves.capRight;\n            }\n        }\n        if (generatedMoves.capLeft !== undefined) {\n            //check that an enemy piece is present to capture left. If not, remove capLeft\n            if (gameState.board.getSquare(generatedMoves.capLeft[0], generatedMoves.capLeft[1]).getPiece() === null || gameState.board.getSquare(generatedMoves.capLeft[0], generatedMoves.capLeft[1]).getPiece().getColor() === this.color) {\n                delete generatedMoves.capLeft;\n            }\n        }\n\n        return Object.values(generatedMoves);\n        }\n\n    getHasNotMoved() {return this.hasNotMoved;}\n}\n\n//# sourceURL=webpack:///./src/pawn.js?");

/***/ }),

/***/ "./src/piece.js":
/*!**********************!*\
  !*** ./src/piece.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Piece; });\nclass Piece {\n    constructor(color, position, name, value) {\n        this.color = color;\n        this.position = position;\n        this.name = name;\n        this.value = value;\n        this.board = gameState.board;\n    }\n\n    valid_moves() {\n\n        let generatedMoves = this._generate_move_sequences();\n\n        generatedMoves = generatedMoves.map(direction => direction.filter(pos => !(pos[0] < 0 || pos[0] > gameState.board.getDims() -1 || pos[1] < 0 || pos[1] > gameState.board.getDims() -1)));\n\n        generatedMoves.forEach((direction) => direction.forEach((pos, index) => {\n            if (gameState.board.getSquare(pos[0], pos[1]).getPiece() !== null && gameState.board.getSquare(pos[0], pos[1]).getPiece().getColor() === this.color) {\n                direction.splice(index);\n            } else if (gameState.board.getSquare(pos[0], pos[1]).getPiece() !== null && gameState.board.getSquare(pos[0], pos[1]).getPiece().getColor() !== this.color) {\n                direction.splice(index + 1);\n            }\n        }))\n\n        return generatedMoves.filter(move => move.length !== 0);\n    }\n\n    _generate_move_sequences() {return [];}\n    getColor() {return this.color;}\n    getPosition() {return this.position;}\n    getName() {return this.name;}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// export class Rook extends Piece {\n//     constructor(color, position) {\n//         super(color, position, 'rook', 5);\n//         this.hasNotMoved = true;\n//     }\n//     _generate_move_sequences() {\n//         let moves = [], rankUp = [], rankDown = [], fileRight = [], fileLeft = [];\n//         let file = this.position[0], rank = this.position[1];\n\n//         for (let i = 1; i < gameState.board.getDims(); i++) {\n//             fileRight.push([file + i, rank]);\n//             fileLeft.push([file - i, rank]);\n//             rankUp.push([file, rank + i]);\n//             rankDown.push([file, rank - i]);\n//         }\n//         moves.push(fileRight), moves.push(fileLeft), moves.push(rankUp), moves.push(rankDown);\n//         return moves;\n//     }\n//     getHasNotMoved() {return this.hasNotMoved;}\n// }\n\n// export class Bishop extends Piece {\n//     constructor(color, position) {\n//         super(color, position, 'bishop', 3);\n//     }\n//     _generate_move_sequences() {\n//         const moves = [], upRight = [], upLeft = [], downRight = [], downLeft = [];\n//         let file = this.position[0], rank = this.position[1];\n\n//         for (let i = 1; i < gameState.board.getDims(); i++) {\n//             upRight.push([file + i, rank + i]);\n//             upLeft.push([file + i, rank - i]);\n//             downRight.push([file - i, rank + i]);\n//             downLeft.push([file -i, rank - i]);\n//         }\n//         moves.push(upRight), moves.push(upLeft), moves.push(downRight), moves.push(downLeft);\n//         return {name: this.name, origin: this.position, moves: moves};\n//     }\n// }\n\n// export class Knight extends Piece {\n//     constructor(color, position) {\n//         super(color, position, 'knight', 3);\n//     }\n//     _generate_move_sequences() {\n//         const moves = [];\n//         let file = this.position[0], rank = this.position[1];\n//         moves.push([file + 2, rank + 1])\n//         moves.push([file + 2, rank - 1])\n//         moves.push([file + 1, rank + 2])\n//         moves.push([file + 1, rank - 2])\n//         moves.push([file - 2, rank + 1])\n//         moves.push([file - 2, rank -1])\n//         moves.push([file - 1, rank + 2])\n//         moves.push([file - 1, rank - 2])\n\n//         return {name: this.name, origin: this.position, moves: moves};\n//     }\n\n//     valid_moves() {\n//         let generatedMoves = this._generate_move_sequences().moves;\n//         let origin = this._generate_move_sequences().origin;\n\n//         generatedMoves = generatedMoves.filter(pos => !(pos[0] < 0 || pos[0] > gameState.board.getDims() -1 || pos[1] < 0 || pos[1] > gameState.board.getDims() -1));\n//         generatedMoves = generatedMoves.filter(move => gameState.board.getSquare(move[0], move[1]).getPiece() === null || gameState.board.getSquare(move[0], move[1]).getPiece().getColor() !== this.color);\n//         return {origin: origin, moves: generatedMoves};\n//     }\n// }\n\n// export class Queen extends Piece {\n//     constructor(color, position) {\n//         super(color, position, 'queen', 9);\n//     }\n//     _generate_move_sequences() {\n//         const moves = [], upRight = [], upLeft = [], downRight = [], downLeft = [], rankUp = [],rankDown = [], fileRight = [], fileLeft = [];\n//         let file = this.position[0], rank = this.position[1];\n\n//         for (let i = 1; i < gameState.board.getDims(); i++) {\n//             upRight.push([file + i, rank + i]);\n//             upLeft.push([file + i, rank - i]);\n//             downRight.push([file - i, rank + i]);\n//             downLeft.push([file -i, rank - i]);\n//             rankUp.push([file + i, rank]);\n//             rankDown.push([file - i, rank]);\n//             fileRight.push([file, rank + i]);\n//             fileLeft.push([file, rank - i]);\n//         }\n//         moves.push(upRight), moves.push(upLeft), moves.push(downRight), moves.push(downLeft);\n//         moves.push(rankUp), moves.push(rankDown), moves.push(fileRight), moves.push(fileLeft);\n//         return {name: this.name, origin: this.position, moves: moves};\n//     }\n// }\n\n// export class King extends Piece {\n//     constructor(color, position) {\n//         super(color, position, 'king', Number.POSITIVE_INFINITY);\n//         this.hasNotMoved = true;\n//     }\n//     _generate_move_sequences() {\n//         const moves = [], upRight = [], upLeft = [], downRight = [], downLeft = [], rankUp = [],rankDown = [], fileRight = [], fileLeft = [];\n//         let file = this.position[0], rank = this.position[1];\n\n//         upRight.push([file + 1, rank + 1]);\n//         upLeft.push([file + 1, rank - 1]);\n//         downRight.push([file - 1, rank + 1]);\n//         downLeft.push([file -1, rank - 1]);\n//         rankUp.push([file + 1, rank]);\n//         rankDown.push([file - 1, rank]);\n//         fileRight.push([file, rank + 1]);\n//         fileLeft.push([file, rank - 1]);\n\n//         moves.push(upRight), moves.push(upLeft), moves.push(downRight), moves.push(downLeft);\n//         moves.push(rankUp), moves.push(rankDown), moves.push(fileRight), moves.push(fileLeft);\n//         return {name: this.name, origin: this.position, moves: moves};\n//     }\n\n//     castle(direction) {\n\n//     }\n\n//     getHasNotMoved() {return this.hasNotMoved;}\n// }\n\n// // Pawn validate moves will take a second to update - look at this closer after class\n\n// class Pawn extends Piece {\n//     constructor(color, position) {\n//         super(color, position, 'pawn', 1);\n//             this.hasNotMoved = true;\n//     }\n//     _generate_move_sequences() {\n\n//         let file = this.position[0], rank = this.position[1];\n\n//         const white_moves = {\n//             forward: [file + 1, rank],\n//             twoSquares: [file + 2, rank],\n//             capRight: [file + 1, rank + 1],\n//             capLeft: [file + 1, rank - 1],\n//         }\n\n//         const black_moves = {\n//             forward: [file - 1, rank],\n//             twoSquares: [file - 2, rank],\n//             capRight: [file - 1, rank + 1],\n//             capLeft: [file - 1, rank - 1],\n//         }\n\n//         if (this.color === 'white') {\n//             return {name: this.name, origin: this.position, moves: white_moves};\n//         } else {\n//             return {name: this.name, black_moves: this.position, moves: black_moves};\n//         }\n//     }\n\n//     valid_moves() {\n//         let generatedMoves = this._generate_move_sequences().moves;\n//         let origin = this._generate_move_sequences().origin;\n//         //if moving forward one space would put the pawn off the board in either direction, delete both \n//         if (generatedMoves.forward[0] > gameState.board.getDims() - 1 || generatedMoves.forward[0] < 0) {\n//             delete generatedMoves.forward;\n//             delete generatedMoves.twoSquares;\n//         }\n//         //if forward one space hits a same color piece, delete both forward options\n//         if (gameState.board.getSquare(generatedMoves.forward[0], generatedMoves.forward[1]).getPiece() !== null && gameState.board.getSquare(generatedMoves.forward[0], generatedMoves.forward[1]).getPiece().getColor() === this.color) {\n//             delete generatedMoves.forward;\n//             delete generatedMoves.twoSquares;\n//         }\n//         //if forward one space is okay, we need to verify forward 2 spaces is also okay. If not, we delete forward two\n//         if (generatedMoves.twoSquares !== undefined) {\n//             if (gameState.board.getSquare(generatedMoves.twoSquares[0], generatedMoves.twoSquares[1]).getPiece() !== null && gameState.board.getSquare(generatedMoves.twoSquares[0], generatedMoves.twoSquares[1]).getPiece().getColor() === this.color) {\n//                 delete generatedMoves.twoSquares;\n//             }\n//         }\n//         //check if capturing right is still on the board. If not, remove capRight\n//         if (generatedMoves.capRight[0]> gameState.board.getDims() - 1 || generatedMoves.capRight[0] < 0 || generatedMoves.capRight[1]> gameState.board.getDims() - 1 || generatedMoves.capRight[1] < 0) {\n//             delete generatedMoves.capRight;\n//         }\n//         //check if capturing left would is still on the board. If not, remove capLeft\n//         if (generatedMoves.capLeft[0]> gameState.board.getDims() - 1 || generatedMoves.capLeft[0] < 0 || generatedMoves.capLeft[1]> gameState.board.getDims() - 1 || generatedMoves.capLeft[1] < 0) {\n//             delete generatedMoves.capLeft;\n//         }\n//         if (generatedMoves.capRight !== undefined) {\n//         //check that an enemy piece is present to capture right. If not, remove capRight\n//             if (gameState.board.getSquare(generatedMoves.capRight[0], generatedMoves.capRight[1]).getPiece() === null || gameState.board.getSquare(generatedMoves.capRight[0], generatedMoves.capRight[1]).getPiece().getColor() === this.color) {\n//                 delete generatedMoves.capRight;\n//             }\n//         }\n//         if (generatedMoves.capLeft !== undefined) {\n//             //check that an enemy piece is present to capture left. If not, remove capLeft\n//             if (gameState.board.getSquare(generatedMoves.capLeft[0], generatedMoves.capLeft[1]).getPiece() === null || gameState.board.getSquare(generatedMoves.capLeft[0], generatedMoves.capLeft[1]).getPiece().getColor() === this.color) {\n//                 delete generatedMoves.capLeft;\n//             }\n//         }\n\n//         return {origin: origin, moves: Object.values(generatedMoves)};\n//         }\n\n//     getHasNotMoved() {return this.hasNotMoved;}\n// }\n\n//# sourceURL=webpack:///./src/piece.js?");

/***/ }),

/***/ "./src/queen.js":
/*!**********************!*\
  !*** ./src/queen.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Queen; });\n/* harmony import */ var _piece__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece */ \"./src/piece.js\");\n\n\nclass Queen extends _piece__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(color, position) {\n        super(color, position, 'queen', 9);\n    }\n    _generate_move_sequences() {\n        const moves = [], upRight = [], upLeft = [], downRight = [], downLeft = [], rankUp = [],rankDown = [], fileRight = [], fileLeft = [];\n        let file = this.position[0], rank = this.position[1];\n\n        for (let i = 1; i < gameState.board.getDims(); i++) {\n            upRight.push([file + i, rank + i]);\n            upLeft.push([file + i, rank - i]);\n            downRight.push([file - i, rank + i]);\n            downLeft.push([file -i, rank - i]);\n            rankUp.push([file + i, rank]);\n            rankDown.push([file - i, rank]);\n            fileRight.push([file, rank + i]);\n            fileLeft.push([file, rank - i]);\n        }\n        moves.push(upRight), moves.push(upLeft), moves.push(downRight), moves.push(downLeft);\n        moves.push(rankUp), moves.push(rankDown), moves.push(fileRight), moves.push(fileLeft);\n        return moves;\n    }\n}\n\n//# sourceURL=webpack:///./src/queen.js?");

/***/ }),

/***/ "./src/rook.js":
/*!*********************!*\
  !*** ./src/rook.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Rook; });\n/* harmony import */ var _piece__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece */ \"./src/piece.js\");\n\n\nclass Rook extends _piece__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(color, position) {\n        super(color, position, 'rook', 5);\n        this.hasNotMoved = true;\n    }\n    _generate_move_sequences() {\n        let moves = [], rankUp = [], rankDown = [], fileRight = [], fileLeft = [];\n        let file = this.position[0], rank = this.position[1];\n\n        for (let i = 1; i < gameState.board.getDims(); i++) {\n            fileRight.push([file + i, rank]);\n            fileLeft.push([file - i, rank]);\n            rankUp.push([file, rank + i]);\n            rankDown.push([file, rank - i]);\n        }\n        moves.push(fileRight), moves.push(fileLeft), moves.push(rankUp), moves.push(rankDown);\n        return moves;\n    }\n    getHasNotMoved() {return this.hasNotMoved;}\n}\n\n//# sourceURL=webpack:///./src/rook.js?");

/***/ }),

/***/ "./src/square.js":
/*!***********************!*\
  !*** ./src/square.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Square; });\nclass Square {\n    constructor(rank, file) {\n        this.letter = 'ABCDEFGH'[file];\n        this.number = rank + 1;\n        this.notation = this.letter + this.number;\n        this.position = [file, rank];\n        this.color;\n        this.piece = null;\n    }\n    setColor(color) {this.color = color;}\n    setPiece(piece) {this.piece = piece;}\n    getPiece() {return this.piece;}\n    removePiece() {this.piece = null;}\n}\n\n//# sourceURL=webpack:///./src/square.js?");

/***/ })

/******/ });